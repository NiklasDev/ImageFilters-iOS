//
//  GLSLFunction.h
//  FiltersApp
//
//  Created by Niklas Ahola on 2/13/14.
//  Copyright (c) 2014 Niklas Ahola. All rights reserved.
//

#define GammaCorrection(color, gamma) pow(color, 1.0 / gamma)

#define LevelsControlInputRange(color, minInput, maxInput) min(max(color - minInput, vec3(0.0)) / (maxInput - minInput), vec3(1.0))
#define LevelsControlInput(color, minInput, gamma, maxInput) GammaCorrection(LevelsControlInputRange(color, minInput, maxInput), gamma)
#define LevelsControlOutputRange(color, minOutput, maxOutput)  mix(minOutput, maxOutput, color)
#define LevelsControl(color, minInput, gamma, maxInput, minOutput, maxOutput) 	LevelsControlOutputRange(LevelsControlInput(color, minInput, gamma, maxInput), minOutput, maxOutput)

#define SHARPEN_UNIFORMS() \
    \
    uniform float imageWidthFactor; \
    uniform float imageHeightFactor;

#define SHARPEN_VARYINGS() \
    \
    varying vec2 textureCoordinate; \
    varying vec2 leftTextureCoordinate; \
    varying vec2 rightTextureCoordinate; \
    varying vec2 topTextureCoordinate; \
    varying vec2 bottomTextureCoordinate; \
    \
    varying float centerMultiplier; \
    varying float edgeMultiplier;

#define SHARPEN_INIT(sharpness) \
    \
    vec2 widthStep = vec2(imageWidthFactor, 0.0); \
    vec2 heightStep = vec2(0.0, imageHeightFactor); \
    \
    textureCoordinate = inputTextureCoordinate.xy; \
    leftTextureCoordinate = inputTextureCoordinate.xy - widthStep; \
    rightTextureCoordinate = inputTextureCoordinate.xy + widthStep; \
    topTextureCoordinate = inputTextureCoordinate.xy + heightStep; \
    bottomTextureCoordinate = inputTextureCoordinate.xy - heightStep; \
    \
    centerMultiplier = 1.0 + 4.0 * sharpness; \
    edgeMultiplier = sharpness;

#define GLSLFUNCTION_STRING2(x) #x
#define GLSLFUNCTION_STRING(text) @ GLSLFUNCTION_STRING2(text)

static NSString* const kGLSLFunction = GLSLFUNCTION_STRING
(
 precision highp float;
 
 varying vec2 leftTextureCoordinate;
 varying vec2 rightTextureCoordinate;
 varying vec2 topTextureCoordinate;
 varying vec2 bottomTextureCoordinate;
 
 varying float centerMultiplier;
 varying float edgeMultiplier;
/* Functions */
 
 
/* Levels
 *
 * Photoshop like levels tools, basic version - set one value for all channel,
 * for set vec3 value use LevelsControl()
 */
 
 vec4 fn_Levels(vec4 color, float minLevel, float midLevel, float maxLevel, float minOut, float maxOut)
 {
     return vec4(LevelsControl(color.rgb, vec3(minLevel), vec3(midLevel), vec3(maxLevel), vec3(minOut), vec3(maxOut)), color.a);
 }
 
 /* Tone Curve
  *
  * Photoshop like tone curve effect;
  *
  * in: vec4 color - source color;
  *     sampler2D texture - generated by 'ToneCurve' class texture;
  *
  * out: vec4 color - color with applying effect.
  */
 
 vec4 fn_ToneCurve(vec4 color,sampler2D texture)
 {
     float redCurveValue = texture2D(texture, vec2(color.r, 0.0)).r;
     float greenCurveValue = texture2D(texture, vec2(color.g, 0.0)).g;
     float blueCurveValue = texture2D(texture, vec2(color.b, 0.0)).b;
     
     return vec4(redCurveValue, greenCurveValue, blueCurveValue, 1.0);
 }
 
 
/* Desaturate
 *
 * in: vec3 color - color for desaturation;
 *     float intensity - intensity level of desaturate (0.0 - origin color, 1.0 - grayscale);
 *
 * out: vec3 desaturated color.
 */
 
 vec4 fn_Desaturate(vec4 color, float intensity)
 {
     const vec3 grayXfer = vec3(0.3, 0.59, 0.11);
     vec3 gray = vec3(dot(grayXfer, color.rgb));
     return vec4(mix(color.rgb, gray, intensity), 1.0);
 }
 
 
/* Brightness
 *
 * in: vec4 color;
 *     float brightness - brightness value, range from -1.0 to 1.0, with 0.0 as the normal level;
 *
 * out: vec4 color with applying Brightness.
 */
 
 vec4 fn_Brightness(vec4 color, float brightness)
 {
     return vec4(color.rgb + vec3(brightness), color.a);
 }
 
 
/* Contrast
 *
 * in: vec4 color;
 *     float contrast - contrast value, range from 0.0 to 4.0, with 1.0 as the normal level;
 *
 * out: vec4 color with applying Contrast.
 */
 
 vec4 fn_Contrast(vec4 color, float contrast)
 {
     return vec4(((color.rgb - vec3(0.5)) * contrast + vec3(0.5)), color.a);
 }
 
 vec4 fn_BrightnessAndContrast(vec4 color, float brightness, float contrast)
 {
     vec4 c = fn_Brightness(color,brightness);
     return fn_Contrast(c,contrast);
 }
 
 
/* Shadow & Highlights
 *
 * in: vec4 source - source color;
 *     float shadows, range from 0.0 to 1.0, increase to lighten shadows, default 0.0;
 *     float highlights, range from 0.0 to 1.0, decrease to darken highlights, default 1.0;
 *
 * out: vec4 color with applying Shadow & Highlights effect.
 */
 
 vec4 fn_ShadowAndHighlights(vec4 source, float shadows, float highlights)
 {
     const vec3 luminanceWeighting = vec3(0.3, 0.3, 0.3);
     
     float luminance = dot(source.rgb, luminanceWeighting);
     
     float shadow = clamp((pow(luminance, 1.0/(shadows+1.0)) + (-0.76)*pow(luminance, 2.0/(shadows+1.0))) - luminance, 0.0, 1.0);
     float highlight = clamp((1.0 - (pow(1.0-luminance, 1.0/(2.0-highlights)) + (-0.8)*pow(1.0-luminance, 2.0/(2.0-highlights)))) - luminance, -1.0, 0.0);
     vec3 result = vec3(0.0, 0.0, 0.0) + ((luminance + shadow + highlight) - 0.0) * ((source.rgb - vec3(0.0, 0.0, 0.0))/(luminance - 0.0));
     
     return vec4(result,1.0);
 }
 
/* Apply Vignette
 *
 * in: vec2 coord - current texture coordinate;
 *     vec4 color - source color;
 *     float start - starting vignette radius, range from 0.0 to 1.0;
 *     float end - ending vignette radious, range from 'start' to 1.0;
 *
 * out: vec4 source color with applying vignette.
 */
 
 vec4 fn_Vignette(vec2 coord, vec4 color, float start, float end)
 {
     float d = distance(coord, vec2(0.5,0.5));
     float percent = smoothstep(start, end, d);
     return vec4(mix(color.rgb, vec3(0.0), percent), 1.0);
 }
 
 /* RGB2HSV
  *
  * convert RGB color to Hue/Saturation/Brightness
  *
  * in: vec3 color - RGB color;
  *
  * out: vec hsv - Hue/Saturation/Brightness color.
  */
 
 vec3 fn_RGB2HSV(vec3 c)
 {
     vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
     vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
     vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
     
     float d = q.x - min(q.w, q.y);
     float e = 1.0e-10;
     return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
 }
 
 /* HSV2RGB
  *
  * convert Hue/Saturation/Brightness color to RGB
  *
  */
 
 vec3 fn_HSV2RGB(vec3 c)
 {
     vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
     vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
     return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
 }
 
 /*
  *
  *
  */
 
 vec4 fn_HSB(vec4 color, float hue, float saturation, float brightness)
 {
     vec3 hsb = fn_RGB2HSV(color.rgb);
     vec3 rgb = fn_HSV2RGB(hsb + vec3(hue,saturation,brightness));
     return vec4(rgb,1.0);
 }
 
 
 /* Sharpen
  *
  * add sharpen effect to texture, for use this function need add -
  * to vertex shader:
  *     SHARPEN_UNIFORMS();
  *     SHARPEN_VARYINGS();
  *     SHARPEN_INIT(sharpness) - in main function, sharpness - sharpen intensity
  *
  * in:
  *     sampler2D texture - texture to apply sharpen effect;
  *     vec2 textureCoordinate - texture coordinate;
  *
  * out:
  *     vec4 color with applying sharpen effect.
  */
 
 vec4 fn_Sharpen(sampler2D texture, vec2 textureCoordinate)
 {
     vec3 textureColor = texture2D(texture, textureCoordinate).rgb;
     vec3 leftTextureColor = texture2D(texture, leftTextureCoordinate).rgb;
     vec3 rightTextureColor = texture2D(texture, rightTextureCoordinate).rgb;
     vec3 topTextureColor = texture2D(texture, topTextureCoordinate).rgb;
     vec3 bottomTextureColor = texture2D(texture, bottomTextureCoordinate).rgb;
     
     return vec4((textureColor * centerMultiplier - (leftTextureColor * edgeMultiplier + rightTextureColor * edgeMultiplier + topTextureColor * edgeMultiplier + bottomTextureColor * edgeMultiplier)), texture2D(texture, bottomTextureCoordinate).w);
 }
 
 
/* Blending */
 
 
/* Multiple Blending
 *
 * Multiplies the source image samples with the background image samples.
 * This results in colors that are at least as dark as either of the two
 * contributing sample colors.
 */
 
 vec4 blend_Multiple(vec4 base, vec4 overlayer)
 {
     return overlayer * base + overlayer * (1.0 - base.a) + base * (1.0 - overlayer.a);
 }
 
 
/* HardLight Blending
 *
 * Either multiplies or screens colors, depending on the source image sample color.
 */
 
 vec4 blend_HardLight(vec4 base, vec4 overlay)
 {
     float ra;
     if (2.0 * overlay.r < overlay.a) {
         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);
     } else {
         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);
     }
     
     float ga;
     if (2.0 * overlay.g < overlay.a) {
         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);
     } else {
         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);
     }
     
     float ba;
     if (2.0 * overlay.b < overlay.a) {
         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);
     } else {
         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);
     }
     
     return vec4(ra, ga, ba, 1.0);
 }
 
 
 /* Overlay Blending
  *
  * Either multiplies or screens the source image samples with the background image samples, depending on the background color.
  */
 
 vec4 blend_Overlay(vec4 base, vec4 overlay)
 {
     float ra;
     if (2.0 * base.r < base.a) {
         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);
     } else {
         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);
     }
     
     float ga;
     if (2.0 * base.g < base.a) {
         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);
     } else {
         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);
     }
     
     float ba;
     if (2.0 * base.b < base.a) {
         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);
     } else {
         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);
     }
     
     return vec4(ra, ga, ba, 1.0);
 }
 
 
 /* Screen Blending
  *
  * Multiplies the inverse of the source image samples with the inverse of the background image samples.
  * This results in colors that are at least as light as either of the two contributing sample colors.
  */
 
 vec4 blend_Screen(vec4 base, vec4 overlay)
 {
     vec4 whiteColor = vec4(1.0);
     return whiteColor - ((whiteColor - overlay) * (whiteColor - base));
 }
 
 
 /* Lighten Blending
  *
  * Creates the composite image samples by choosing the lighter samples (either from the source image or the background).
  */
 
 vec4 blend_Lighten(vec4 base, vec4 overlay)
 {
     return max(base, overlay);
 }

 /*  Color Dodge Blending
  *
  *
  */

 vec4 blend_ColorDodge(vec4 base, vec4 overlay)
 {
    vec3 baseOverlayAlphaProduct = vec3(overlay.a * base.a);
    vec3 rightHandProduct = overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a);
    
    vec3 firstBlendColor = baseOverlayAlphaProduct + rightHandProduct;
    vec3 overlayRGB = clamp((overlay.rgb / clamp(overlay.a, 0.01, 1.0)) * step(0.0, overlay.a), 0.0, 0.99);
    
    vec3 secondBlendColor = (base.rgb * overlay.a) / (1.0 - overlayRGB) + rightHandProduct;
    
    vec3 colorChoice = step((overlay.rgb * base.a + base.rgb * overlay.a), baseOverlayAlphaProduct);
    
    return vec4(mix(firstBlendColor, secondBlendColor, colorChoice), 1.0);
 }

 highp float lum(lowp vec3 c) {
     return dot(c, vec3(0.3, 0.59, 0.11));
 }
 
 lowp vec3 clipcolor(lowp vec3 c) {
     highp float l = lum(c);
     lowp float n = min(min(c.r, c.g), c.b);
     lowp float x = max(max(c.r, c.g), c.b);
     
     if (n < 0.0) {
         c.r = l + ((c.r - l) * l) / (l - n);
         c.g = l + ((c.g - l) * l) / (l - n);
         c.b = l + ((c.b - l) * l) / (l - n);
     }
     if (x > 1.0) {
         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);
         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);
         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);
     }
     
     return c;
 }
 
 lowp vec3 setlum(lowp vec3 c, highp float l) {
     highp float d = l - lum(c);
     c = c + vec3(d);
     return clipcolor(c);
 }
 
 highp float sat(lowp vec3 c) {
     lowp float n = min(min(c.r, c.g), c.b);
     lowp float x = max(max(c.r, c.g), c.b);
     return x - n;
 }
 
 lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {
     return ((cmid - cmin) * s) / (cmax - cmin);
 }
 
 lowp vec3 setsat(lowp vec3 c, highp float s) {
     if (c.r > c.g) {
         if (c.r > c.b) {
             if (c.g > c.b) {
                 /* g is mid, b is min */
                 c.g = mid(c.b, c.g, c.r, s);
                 c.b = 0.0;
             } else {
                 /* b is mid, g is min */
                 c.b = mid(c.g, c.b, c.r, s);
                 c.g = 0.0;
             }
             c.r = s;
         } else {
             /* b is max, r is mid, g is min */
             c.r = mid(c.g, c.r, c.b, s);
             c.b = s;
             c.r = 0.0;
         }
     } else if (c.r > c.b) {
         /* g is max, r is mid, b is min */
         c.r = mid(c.b, c.r, c.g, s);
         c.g = s;
         c.b = 0.0;
     } else if (c.g > c.b) {
         /* g is max, b is mid, r is min */
         c.b = mid(c.r, c.b, c.g, s);
         c.g = s;
         c.r = 0.0;
     } else if (c.b > c.g) {
         /* b is max, g is mid, r is min */
         c.g = mid(c.r, c.g, c.b, s);
         c.b = s;
         c.r = 0.0;
     } else {
         c = vec3(0.0);
     }
     return c;
 }
 
 vec4 blend_Hue(vec4 base, vec4 overlay)
 {
     return vec4(base.rgb * (1.0 - overlay.a) + setlum(setsat(overlay.rgb, sat(base.rgb)), lum(base.rgb)) * overlay.a, base.a);
 }
 
);


